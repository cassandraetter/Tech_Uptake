---
title: "Edits Notebook"
author: "Cassandra Etter"
date: "2024-11-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is the data behind the EDITS work. It follows four steps. For Step 1 I look at uptake rates between 2010 and 2021 in three countries: US, UK and Germany. For the US, I use the PSID which tracks households between 2011- 2021 on a biannual basis. For Germany, I use SOEP which tracks households between 2010- 2021 on an annual basis, and for the UK I use Understanding Society which tracks households between 2010 - 2021 on an annual basis. All data was downloaded in September 2024 and cleaning files are on github.

8 technologies selected are :Internet Access, own a smartphone, Home has Solar, Home switched from Gas/Coal/Wood to electric (fuel switching), Home renovation/ retrofitting, EV/ Hybrid car, Commuting habit (walking, biking), digital skills/ capabilities (daily use of internet).

Note: Significant limitations on technologies surveyed. With better data, I could also do this for smart-meters, air conditioners, etc.

```{r libraries,include=FALSE}
library(DiagrammeR)
library(ggplot2)
library(dplyr)
library(tidyr)
library(survey)
library(priceR)
library(readr)
library(tidyverse)
library(nls2)
library(drc)
library(forecast)
library(nls2)
library(quantmod)
library(scales)
library(data.table)
library(minpack.lm)
library(countrycode)
library(modelsummary)
library(knitr)
library(kableExtra)
library(broom)
```


```{r load UK DEU, include=FALSE}

UK <- read_csv("~/Documents/Github/PhD/Data/UK_Clean.csv")
DEU <- read_csv("~/Documents/Github/PhD/Data/DEU_Clean.csv", show_col_types = FALSE)
US <- read_csv("~/Documents/Github/PhD/Data/US_EDITS.csv", show_col_types = FALSE)


```
## Income Minimum Threshold ### 
For our data, we have a number of households that state they make way below a ''living salary''. To calculate the floor, I make a grand assumption that at least one individual in the home is working full time on minimum wage salary. For the US, this amount doesn't change and is $1,150 net per month, or 13,800 per year. For Germany €8.50 in 2015 €8.84 in 2017 and €9.19 in 2019.

This eliminates 105 observations. 

```{r income minimum, echo = FALSE}

US_filter<- US %>%
  filter(hh_income >= 1150) %>%
  filter(adjusted_income >= 1150)
```

## Step 1: Uptake Rates

This provides a snapshot for current uptake across the households assessing heterogeneity across income level.

### U.S. Uptake Rates

For the US, I have information for solar ownership, EV/ hybrid ownership, smartphone ownership, internet access, and commute habit. I create an additional variable on fuel switching by looking at heating method and seeing where moved from wood, oil, gas, coal to electric heating. I also create a variable for retrofitting based on home renovations and skills based on survey responses where RP responds they use the internet daily.

Note: Smartphone ownership and digital skills questions were only added to the survey in 2015.

```{r US Uptake Rates, echo=FALSE}
US <- US %>%
  group_by(pid) %>%
  arrange(pid, year) %>%
  mutate(
    # Create a combined solar indicator
    is_solar = heat_method == 6 | heat_method_2 == 6 | heat_method_3 == 6,
    
    # Track those who switched to electric
    switched_to_electric = (lag(heat_method) %in% c(1,3,4,5,10,11) |
                    lag(heat_method_2) %in% c(1,3,4,5,10,11) |
                    lag(heat_method_3) %in% c(1,3,4,5,10,11)) & 
                          heat_method == 2,
    
    # Track those using electricity 
    always_electric = all(heat_method == 2, na.rm = TRUE),
        switched_to_solar = lag(is_solar) == FALSE & is_solar == TRUE,
        always_solar = all(is_solar, na.rm = TRUE),
        using_electric = heat_method == 2,
    using_solar = is_solar,
        switch_year_electric = case_when(
      switched_to_electric ~ year,
      TRUE ~ NA_real_
    ),
    switch_year_solar = case_when(
      switched_to_solar ~ year,
      TRUE ~ NA_real_
    )
  ) %>%
  ungroup() %>%
  filter(year > 2010)
# For decile analysis:
uptake_rates <- US %>%
  group_by(year, weighted_decile) %>%
  summarise(
    total_households = n_distinct(pid),
    
    # Electric heating metrics
    new_electric_switches = sum(switched_to_electric, na.rm = TRUE),
    total_electric_users = sum(using_electric, na.rm = TRUE),
    
    # Solar heating metrics
    new_solar_switches = sum(switched_to_solar, na.rm = TRUE),
    total_solar_users = sum(using_solar, na.rm = TRUE),
    
    # Calculate rates
    electric_switch_rate = (new_electric_switches / total_households) * 100,
    total_electric_rate = (total_electric_users / total_households) * 100,
    solar_switch_rate = (new_solar_switches / total_households) * 100,
    total_solar_rate = (total_solar_users / total_households) * 100
  ) %>%
  ungroup()

us_props <- US %>%
  group_by(year, weighted_decile) %>%
  summarise(
    n_total = n(),
    smartphone_prop = mean(smartphone == 1, na.rm = TRUE),
    hybrid_prop = mean(hybrid == 1 | hybrid_2 == 1 | hybrid_3 == 1, na.rm = TRUE), # includes EVs 
    solar_prop = mean(heat_method == 6 | heat_method_2 ==6 | heat_method_3 == 6, na.rm = TRUE),
    internet_prop = mean(computer == 1, na.rm = TRUE),     # Computer ownership
    renovation_prop = mean(hh_repair > 1, na.rm = TRUE), 
    skills_prop = mean(internet == 1, na.rm = TRUE),       # Internet usage
    fuel_switch_prop = mean(heat_method == 2 & 
                                                (heat_method_2 == 0 | heat_method_2 == 2 | heat_method_2 == 6) &
                                                (heat_method_3 == 0 | heat_method_3 == 2 | heat_method_3 == 6), 
                                        na.rm = TRUE)
  ) %>%
  mutate(
    smartphone_percent = smartphone_prop * 100,            # Remove duplicate line
    hybrid_percent = hybrid_prop * 100,
    solar_percent = solar_prop * 100, 
    internet_percent = internet_prop * 100, 
    repairs_percent = renovation_prop * 100, 
    skills_percent = skills_prop * 100,
    fuel_switch_percent = fuel_switch_prop * 100 
  )


us_props_long <- us_props %>%
  dplyr::select(year, weighted_decile, smartphone_percent, hybrid_percent, solar_percent, 
         internet_percent, repairs_percent, skills_percent, 
         fuel_switch_percent) %>%
  pivot_longer(
    cols = c(smartphone_percent, hybrid_percent, solar_percent, 
             internet_percent, repairs_percent, skills_percent, 
             fuel_switch_percent),
    names_to = "technology",
    values_to = "percentage"
  ) %>%
  mutate(technology = factor(technology, 
    levels = c("smartphone_percent", "hybrid_percent", "solar_percent", 
               "internet_percent", "repairs_percent", "skills_percent", 
               "fuel_switch_percent"),
    labels = c("Smartphone", "Hybrid/EV", "Solar Panels", "Internet", 
               "Home Renovations", "Digital Skills", "Clean Heating Switch")))
# Create the plot
ggplot(us_props_long, aes(x = weighted_decile, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~year) +
  theme_minimal() +
  labs(
    title = "Technology Adoption by Income Decile in US",
    x = "Income Decile",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  scale_x_continuous(breaks = 1:10) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    panel.grid.minor = element_blank()
  ) +
  guides(color = guide_legend(nrow = 2)) # Makes legend more compact

# Plot across time
ggplot(us_props_long, aes(x = year, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~weighted_decile) +
  theme_minimal() +
  labs(
    title = "Technology Adoption Over Time by Income Decile",
    x = "Year",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    panel.grid.minor = element_blank()
  ) +
  guides(color = guide_legend(nrow = 2))
```

Clean heating is interesting in that high income households had less electric only and marginally increased over 2011 - 2021 time period, though they still did increase within decile 9 and 10. Solar panel infiltration is lower than national average at 1% with EIA estimating 4%.

### U.K. Uptake Rates

For the UK, I have solar, EV/ hybrid, smartphone, internet, commute and skills. I create fuel switching in the same manner as for US, buy looking at home energy bills and looking for those households that switch from gas/coal to electric only.

Solar question is only asked in 2009, 2012, 2018, and 2021. EV is asked in 2012, 2015, 2018, and 2021. Smartphone begins in 2013. Skills starts in 2011.

Commuting habit question changes in 2018 to a new question, so I only track to 2017. 

```{r UK Uptake Rates, echo=FALSE}
# UK proportions
uk_props <- UK %>%
  group_by(year, weighted_decile) %>%
  summarise(
    n_total = n(),
    solar_prop = mean(solar1 %in% c("yes - fitted", "Yes - fitted") | 
                        solar2 %in% c("yes - fitted", "Yes - fitted") |
                        solar3 %in% c("yes - fitted", "Yes - fitted"), na.rm = TRUE),
     hybrid_prop = mean(
            carfuel1 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") |
            carfuel2 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") | 
              carfuel3 %in%  c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") |
              carfuel4 %in%  c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)"), na.rm = TRUE),
    smartphone_prop = mean(smartmob %in% c("Yes", "yes"), na.rm = TRUE ),
    skills_prop = mean(netpuse %in% c("Every day", "every day") | netpusenew %in% c("Every day", "every day"), na.rm = TRUE),
    internet_prop = mean(pcnet %in% c("yes", "Yes"), na.rm = TRUE),
     commute_prop = mean(
                        case_when(
                                year < 2018 ~ worktrav %in% c(
                                        "Bus/coach", "bus/coach", "Cycle", "cycle", "Walk", "walk",
                                        "Train", "train", "Underground/Metro/Tram/Light railway", 
                                        "underground/metro/tram/light railway",
                                        "underground/metro/tram/light railway (if england/scotland/wales)",
                                        "underground/metro/tram/light railway {if region = gb}",
                                        "Motorcycle/moped/scooter", "motorcycle/moped/scooter"
                                ),
                                year >= 2018 ~ (wktrv10 == "Yes mentioned" |  # Underground/metro
                                                        wktrv6 == "Yes mentioned" |   # Bus
                                                        wktrv7 == "Yes mentioned" |   # Train
                                                        wktrv9 == "Yes mentioned" |   # Walk
                                                        wktrv8 == "Yes mentioned")   # Cycle
                        ),
                        na.rm = TRUE
                ),
    fuel_switch_prop = mean(xpelecy > 0 & 
                                                (xpgasy <= 0 | is.na(xpgasy)) & 
                                                (xpoily <= 0 | is.na(xpoily)), 
                                        na.rm = TRUE)) %>%
  mutate(
    solar_percent = solar_prop * 100,
    ev_percent = hybrid_prop * 100,
    smartphone_percent = smartphone_prop * 100, 
    internet_percent = internet_prop * 100, 
    commute_percent = commute_prop * 100,
    skills_percent = skills_prop * 100, 
    fuel_switch_percent = fuel_switch_prop * 100
  )

# Convert to long format with all technologies
uk_props_long <- uk_props %>%
  dplyr::select(year, weighted_decile, solar_percent, ev_percent, smartphone_percent, 
         internet_percent, skills_percent, commute_percent, fuel_switch_percent) %>%
  pivot_longer(
    cols = c(solar_percent, ev_percent, smartphone_percent, 
             internet_percent, skills_percent, commute_percent, fuel_switch_percent),
    names_to = "technology",
    values_to = "percentage"
  ) %>%
  mutate(technology = factor(technology, 
    levels = c("ev_percent", "solar_percent", "smartphone_percent", 
               "internet_percent", "skills_percent", "commute_percent", "fuel_switch_percent"),
    labels = c("Hybrid/EV", "Solar Panels", "Smartphone", 
               "Internet", "Digital Skills", "Sustainable Transport", "Clean Heating Switch")))

ggplot(uk_props_long, aes(x = weighted_decile, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~year) +
  theme_minimal() +
  labs(
    title = "Technology Adoption by Income Decile in UK",
    x = "Income Decile",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  scale_x_continuous(breaks = 1:10) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    panel.grid.minor = element_blank()
  ) +
  guides(color = guide_legend(nrow = 2)) # Makes legend more compact

ggplot(uk_props_long[uk_props_long$percentage != 0, ], aes(x = year, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~weighted_decile) +
  theme_minimal() +
  labs(
    title = "Technology Adoption Over Time by Income Decile UK",
    x = "Year",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    panel.grid.minor = element_blank()
  ) +
  guides(color = guide_legend(nrow = 2))



```

### Germany Uptake Rates

For Germany I have information on solar, EV, retrofitting, smartphone, internet.

EV only exists in 2015 and 2020. (note it is full EV or hydrogen, no hybrid category). Remove this variable as 2015 only has 1 response per decile and 2020 isn't much better. 

Retrofitting is asked from 2010 - 2015, and 2019. 

Smartphone hits 100% adoption in 2016, and SOEP stop asking the question. 
```{r rename syear, include=FALSE}
DEU <- DEU %>%
  rename(year = syear)
```

```{r DEU Uptake Rates, echo=FALSE}

deu_props <- DEU %>%
  group_by(year, weighted_decile) %>%
  summarise(
    n_total = n(),
    hybrid_prop = ifelse(sum(!is.na(c(hli0121, hli0122, hli0123, hli0124, hli0128, hli0129, hli0130, hli0131))) == 0, 
                     NA_real_, 
                     sum(hli0121 == 1 | hli0122 == 1 | hli0123 == 1 | hli0124 == 1 | 
                         hli0128 == 1 | hli0129 == 1 | hli0130 == 1 | hli0131 == 1, 
                         na.rm = TRUE) / n()),
    solar_prop = sum(hgeqpsol == 1 | hgeqpnrj == 1 , na.rm = TRUE) / 
             sum(hgeqpsol %in% c(1, 2) | hgeqpnrj %in% c(1, 2), na.rm = TRUE),
    renovation_prop = sum(hgcondit == 2 | hgcondit == 3, na.rm = TRUE) /n(),
    smartphone_prop = if(first(year) > 2015) {
                        1
                } else {
                        sum(hgeqptel == 1, na.rm = TRUE) / n()
                },
    internet_prop = sum(hlf0178_h == 1, na.rm = TRUE) / 
                  sum(hlf0178_h %in% c(1, 2), na.rm = TRUE),
    fuel_switch_prop = if(first(year) >= 2016) {
                        sum(energy_combination == 3, na.rm = TRUE) / n()
                } else {
                        NA_real_
                }
  ) %>%
  group_by(weighted_decile) %>%
  arrange(year) %>%
  mutate(
    internet_prop = if_else(year == 2020, NA_real_, internet_prop ) ## 2020 had different methodology in survey
  ) %>%
   mutate(
    hybrid_percent = ifelse(hybrid_prop == 0, NA_real_, hybrid_prop * 100),
    solar_percent = ifelse(solar_prop == 0, NA_real_, solar_prop * 100), 
    renovation_percent = ifelse(renovation_prop == 0, NA_real_, renovation_prop * 100), 
    smartphone_percent = ifelse(smartphone_prop == 0, NA_real_, smartphone_prop * 100),
    internet_percent = ifelse(internet_prop == 0, NA_real_, internet_prop * 100),
    fuel_switch_percent = ifelse(fuel_switch_prop == 0, NA_real_, fuel_switch_prop * 100)
  )


deu_props_long <- deu_props %>%
  dplyr::select(year, solar_percent, renovation_percent, smartphone_percent, internet_percent, fuel_switch_percent, hybrid_percent) %>%  
  pivot_longer(
    cols = c( solar_percent, renovation_percent, smartphone_percent, internet_percent, fuel_switch_percent, hybrid_percent),
    names_to = "technology",
    values_to = "percentage"
  ) %>%
  mutate(technology = factor(technology, 
    levels = c( "solar_percent", "renovation_percent", "smartphone_percent", "internet_percent", "fuel_switch_percent", "hybrid_percent"),
    labels = c("Solar Panels", "Home Renovations", "Owns a Smartphone", "Internet access", "Clean Heating Switch", "Hybrid/EV")))

ggplot(deu_props_long, aes(x = weighted_decile, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~year) +
  theme_minimal() +
  labs(
    title = "Technology Adoption by Income Decile in Germany",
    x = "Income Decile",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  scale_x_continuous(breaks = 1:10) +
  theme(legend.position = "bottom")

ggplot(deu_props_long, aes(x = year, y = percentage, color = technology)) +
  geom_line() +
  geom_point() +
  facet_wrap(~weighted_decile) +
  theme_minimal() +
  labs(
    title = "Technology Adoption Over Time by Income Decile Germany",
    x = "Year",
    y = "Percentage of Households (%)",
    color = "Technology"
  ) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    panel.grid.minor = element_blank()
  ) +
  guides(color = guide_legend(nrow = 2))



```

### Combined Uptake Rates
Not all technologies in each country have the same year of start and end data. I now get data as close to 2015 start and 2021 end as possible. Look at year ranges available for uptake rates for each country and technology at decile level. 

THIS IS NOT USEFUL-- IGNORE

```{r combined uptake rates, echo=FALSE}

# Calculate uptake rates for US
us_uptake_rates <- map_df(unique(us_props_long$technology), function(tech) {
  us_props_long %>%
    filter(
      technology == tech,
      year %in% c(2015, 2021)
    ) %>%
    dplyr::select(year, weighted_decile, technology, percentage) %>%
    pivot_wider(
      names_from = year,
      values_from = percentage
    ) %>%
    mutate(
      start_year = 2015,
      uptake_rate = !!sym(as.character(2021)) - !!sym(as.character(2015)),
      country = "US"
    )
})

# Calculate uptake rates for UK
uk_uptake_rates <- map_df(unique(uk_props_long$technology), function(tech) {
  # Set start year based on technology
  start_year <- if(tech == "Solar Panels") {
    2012
  } else {
    2015
  }
  
  # Set end year based on technology
  end_year <- if(tech == "Digital Skills") {
    2019
  } else {
    2021
  }
  
  uk_props_long %>%
    filter(
      technology == tech,
      year %in% c(start_year, end_year)
    ) %>%
    dplyr::select(year, weighted_decile, technology, percentage) %>%
    pivot_wider(
      names_from = year,
      values_from = percentage
    ) %>%
    mutate(
      start_year = start_year,
      end_year = end_year,
      uptake_rate = !!sym(as.character(end_year)) - !!sym(as.character(start_year)),
      country = "UK"
    )
})

deu_uptake_rates <- map_df(unique(deu_props_long$technology), function(tech) {
  # Set start year based on technology
  start_year <- if(tech == "Home Renovations") {
    2010
  } else {
    2015  
  }
  
  # Set end year based on technology
  end_year <- case_when(
    tech == "Home Renovations" ~ 2015, 
    tech == "Hybrid/EV" ~ 2020,
    TRUE ~ 2021
  )
  
  deu_props_long %>%
    filter(
      technology == tech,
      year %in% c(start_year, end_year)
    ) %>%
    dplyr::select(year, weighted_decile, technology, percentage) %>%
    pivot_wider(
      names_from = year,
      values_from = percentage
    ) %>%
    mutate(
      start_year = start_year,
      end_year = end_year,
      uptake_rate = !!sym(as.character(end_year)) - !!sym(as.character(start_year)),
      country = "Germany"
    )
})
# Combine all datasets
all_uptake_rates <- bind_rows(us_uptake_rates, uk_uptake_rates, deu_uptake_rates)

# Print summary of start years used
print("Start years used for each technology by country:")
all_uptake_rates %>%
  distinct(country, technology, start_year) %>%
  arrange(country, technology) %>%
  print(n = Inf)

# Create heatmap
heatmap_all <- ggplot(all_uptake_rates, 
  aes(x = factor(weighted_decile), 
      y = paste0(technology, " (", start_year, "-", ifelse(country == "Germany" & technology == "Home Renovation", "2019", "2021"), ")"), 
      fill = uptake_rate)) +
  geom_tile() +
  scale_fill_gradient2(
    low = "red",
    mid = "white",
    high = "darkgreen",
    midpoint = 0,
    limits = c(-5, 5),
    oob = scales::squish
  ) +
  theme_minimal() +
  facet_wrap(~country) +
  labs(
    title = "Technology Uptake Rates by Income Decile",
    subtitle = "Percentage Point Change in Adoption (Capped at ±5 percentage points)",
    x = "Income Decile",
    y = NULL,
    fill = "Percentage\nPoint Change"
  ) +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.text.y = element_text(hjust = 1),
    legend.position = "right"
  )

# Create boxplot
boxplot_all <- ggplot(all_uptake_rates, 
  aes(y = paste0(technology, " (", start_year, "-", ifelse(country == "Germany" & technology == "Home Renovations", "2019", "2021"), ")"), 
      fill = country)) +
  geom_vline(xintercept = 0, color = "grey80", linetype = "dashed") +
  geom_boxplot(aes(x = uptake_rate), width = 0.7, alpha = 0.7, position = position_dodge(width = 0.8)) +
  scale_fill_brewer(palette = "Set2") +
  theme_minimal() +
  labs(
    title = "Technology Uptake Distribution by Type and Country",
    subtitle = "Boxplots show distribution across income deciles",
    x = "Percentage Point Change",
    y = NULL,
    fill = "Country"
  ) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank(),
    legend.position = "bottom"
  )

# Display plots
heatmap_all
boxplot_all
```

There are two outlier technologies for uptake rates. The first is Sustainable Transit in the UK. UK commute (sustainable transport) only shows commuting patterns for those who work, so potentially hides significant commuting preferences, particularly for those out of work or job seeking and is being compared against COVID so less people were commuting to work in 2021, no matter their method. The second is home renovations in Germany. If i change the year to later, the figure does go up, but 2010 shows a renovation boom that is lost in later years.


### S-Curve - summary data

Simple Non linear Regression 
```{r s-curve, echo=FALSE}
# Configure maximum penetration hypothesis
max_penetration <- tribble(
  ~tech, ~max_share,
  'solar', 0.9,
  'smartphone', 1,
  'skills', 0.95,
  'internet', 1,
  'hybrid', 0.5,
  'commute', 0.5,
  'fuel_switch', 0.7,
  'renovation', 0.75,
) %>% as.data.table

# Aggregate all 3 countries to the quintile level,
# and combine them to a single data.table
props_long <- bind_rows(
  deu_props %>% mutate(iso2 = "DE") ,
  uk_props  %>% mutate(iso2 = "GB"),
  us_props  %>% mutate(iso2 = "US") 
) %>%
  mutate(quintile = (weighted_decile - 1) %/% 2 + 1) %>% group_by(iso2, year, quintile) %>%
  summarise(across(ends_with('prop'), ~weighted.mean(., n_total, na.rm = TRUE))) %>% as.data.table %>%
  melt(id.vars = c('iso2', 'year', 'quintile'), value.name = 'share', variable.name = 'tech') %>%
  mutate(tech = str_remove(tech, '_prop')) %>%
  # The logistics curve will be fitted to non-zero, non-NA shares
  filter(share != 0, !is.na(share),
         # There's apparently a problem in the computation of the Commute share over 2018:2021 in the UK
         !(year %in% 2018:2021 & tech == 'commute'),
         # Not enough observations (2) for hybrids in Germany
         !(iso2 == 'DE' & tech == 'hybrid'),
         # Problem with solar in the US: only one observation for quintile 2
         !(iso2 == 'US' & tech == 'solar')
  )


# Function to obtain a fit for a particular iso2 x technology x quintile triplet
nlsTechnology <- function(dt, max_penetration, growth_rate, inflexion_year) {
  .tech <- dt$tech[1]; .quintile <- dt$quintile[1]; .iso2 <- dt$iso2[1]

  target_2100 <- tail(props_long[iso2 == .iso2 & quintile == .quintile & tech == .tech], 1)
  target_2100$year <- 2100
  target_2100$share <- max_penetration
  dt <- rbindlist(list(dt, target_2100))

  dt %>%
    minpack.lm::nlsLM(share ~ max_penetration / (1 + exp(-growth_rate * (year - inflexion_year))), .,
                      start = list(
                        max_penetration = max_penetration,
                        growth_rate = growth_rate,
                        inflexion_year = inflexion_year
                      ),
                      lower = c('max_penetration' = 0, 'growth_rate' = 0, 'inflexion_year' = 1900),
                      upper = c('max_penetration' = max_penetration, 'growth_rate' = 0.15, 'inflexion_year' = 2500),
                      control = nls.lm.control(maxfev = 4000, maxiter = 1024)
    )
}

# Market penetration fits across all countries, technologies and quintiles
tech_penetration_fits <- sapply(unique(props_long$iso2) %>% sort, function(.iso2) {
  print(.iso2)
  lapply(unique(props_long[iso2 == .iso2]$quintile) %>% sort, function(.quintile) {
    print(.quintile)
    sapply(unique(props_long[iso2 == .iso2]$tech), function(.tech) {
      print(.tech)
      props_long[iso2 == .iso2 & quintile == .quintile & tech == .tech] %>%
        nlsTechnology(
          max_penetration = max(max_penetration[tech == .tech]$max_share,
                                max(props_long[iso2 == .iso2 & quintile == .quintile & tech == .tech]$share)),
          growth_rate = 0.1, inflexion_year = 2025
        )
    }, simplify = FALSE, USE.NAMES = TRUE)
  })
}, simplify = FALSE, USE.NAMES = TRUE)


# Plot results for a given country
plotCountry <- function(.iso2) {
  lapply(unique(props_long[iso2 == .iso2]$tech), function(.tech) {
    lapply(1:5, function(.quintile) {
      data.table(year = 2000:2100, quintile = .quintile) %>%
        mutate(predicted_share = predict(tech_penetration_fits[[.iso2]][[.quintile]][[.tech]],
                                         newdata = list(year = year)),
               tech = .tech)
    }) %>% rbindlist
  }) %>% rbindlist %>%
    mutate(iso2 = .iso2) %>%
    left_join(props_long, by = c('iso2', 'year', 'tech', 'quintile')) %>%
    mutate(quintile = str_c('Q', quintile)) %>%
    ggplot(aes(year, predicted_share, color = tech)) +
    geom_line() +
    geom_point(aes(year, share, color = tech), size = 1) +
    facet_grid(vars(quintile), vars(tech), switch = "y") +
    scale_y_continuous(labels = scales::label_percent()) +
    scale_x_continuous(breaks = c(2000, 2050, 2100)) +
    xlab('') + ylab('Penetration rate') +
    ggtitle(countrycode(.iso2, 'iso2c', 'country.name')) +
    theme_minimal() +
    theme(legend.position = 'none',
          text = element_text(size = 14))
}

plotCountry('DE')
plotCountry('GB')
plotCountry('US')

## Regression tables
tech_penetration_fits[['DE']] %>% `names<-`(str_c("Quintile ", 1:5)) %>%
  modelsummary(stars = c('*' = 0.1, '**' = 0.05, '***' = 0.01),
               shape = 'rbind')

tech_penetration_fits[['GB']] %>% `names<-`(str_c("Quintile ", 1:5)) %>%
  modelsummary(stars = c('*' = 0.1, '**' = 0.05, '***' = 0.01),
               shape = 'rbind')

tech_penetration_fits[['US']] %>% `names<-`(str_c("Quintile ", 1:5)) %>%
  modelsummary(stars = c('*' = 0.1, '**' = 0.05, '***' = 0.01),
               shape = 'rbind')


```

In the baseline model  Model aims to reach exogenously government provided diffusion target for each technology (e.g.40% for housing retrofit vs 60% for EVs) in each country. Desk research to find target. 

General findings: Digital technologies (internet and smartphone) are earliest adopters and have highest penetration. Q5 generally leads adoption. Energy technologies are much later. Renovation has a very slow increase compared to technologies. 

Now, to improve with technology and country specific policies. 

GERMANY
Solar -- goal of 80-95% solar installation on homes by 2050
Internat -- goal of 100% by 2030 in digitalstrategie deutschland
smartphone --- Digitalstrategie Deutschland state 2030 everyone should have
skills -- EU have a 80% by 2030 goal in EU Digital Decade Strategy
hybrid/ev -- they have a 100% new sales goal, 
commute --2030 Federal Infrastructure Plan lists expected growth to 2030 to be 20% increase  
fuel switching-- 60% RE energy consumption across the board by 2050 in Buildings Strategy, Energieweshel has focus on heat pumps and district heating at 45% of all heating solutions
renovation -- 1% annual to 2% annual in the Buildings Strategy so 45% renovation in 2019 would be 83.14% renovated in 2050

```{r s-curve improved, echo = FALSE}
# Configure maximum penetration hypothesis
max_penetration <- tribble(
        ~iso2, ~tech, ~max_share,
        # Germany
        'DE', 'solar', 0.95,
        'DE', 'smartphone', 1.0,
        'DE', 'skills', 0.8,
        'DE', 'internet', 1.0,
        'DE', 'hybrid', 1.0,
        'DE', 'commute', 0.3,
        'DE', 'fuel_switch', 0.45,
        'DE', 'renovation', 0.83,
        # US (using original values)
        'US', 'solar', 0.9,
        'US', 'smartphone', 1.0,
        'US', 'skills', 0.95,
        'US', 'internet', 1.0,
        'US', 'hybrid', 0.5,
        'US', 'commute', 0.5,
        'US', 'fuel_switch', 0.7,
        'US', 'renovation', 0.75,
        # GB (using US values for now - you can modify these)
        'GB', 'solar', 0.9,
        'GB', 'smartphone', 1.0,
        'GB', 'skills', 0.95,
        'GB', 'internet', 1.0,
        'GB', 'hybrid', 0.5,
        'GB', 'commute', 0.5,
        'GB', 'fuel_switch', 0.7,
        'GB', 'renovation', 0.75
) %>% as.data.table

# Aggregate all 3 countries to the quintile level,
# and combine them to a single data.table
props_long <- bind_rows(
        deu_props %>% mutate(iso2 = "DE"),
        uk_props  %>% mutate(iso2 = "GB"),
        us_props  %>% mutate(iso2 = "US")
) %>%
        mutate(quintile = (weighted_decile - 1) %/% 2 + 1) %>% 
        group_by(iso2, year, quintile) %>%
        summarise(across(ends_with('prop'), ~weighted.mean(., n_total, na.rm = TRUE))) %>% 
        as.data.table %>%
        melt(id.vars = c('iso2', 'year', 'quintile'), 
             value.name = 'share', 
             variable.name = 'tech') %>%
        mutate(tech = str_remove(tech, '_prop')) %>%
        filter(share != 0, !is.na(share))

# Function to obtain a fit for a particular iso2 x technology x quintile triplet
nlsTechnology <- function(dt, max_penetration, growth_rate, inflexion_year) {
        .tech <- dt$tech[1]
        .quintile <- dt$quintile[1]
        .iso2 <- dt$iso2[1]
        
        country_max <- max_penetration
        
        target_2050 <- tail(props_long[iso2 == .iso2 & 
                                               quintile == .quintile & 
                                               tech == .tech], 1)
        target_2050$year <- 2050
        target_2050$share <- country_max
        dt <- rbindlist(list(dt, target_2050))
        
        dt %>%
                minpack.lm::nlsLM(
                        share ~ country_max / (1 + exp(-growth_rate * (year - inflexion_year))),
                        .,
                        start = list(
                                country_max = country_max,
                                growth_rate = growth_rate,
                                inflexion_year = inflexion_year
                        ),
                        lower = c('country_max' = 0, 
                                  'growth_rate' = 0, 
                                  'inflexion_year' = 1900),
                        upper = c('country_max' = country_max, 
                                  'growth_rate' = 0.15, 
                                  'inflexion_year' = 2500),
                        control = nls.lm.control(maxfev = 4000, maxiter = 1024)
                )
}

# Market penetration fits across all countries, technologies and quintiles
tech_penetration_fits <- sapply(unique(props_long$iso2) %>% sort, function(.iso2) {
        print(.iso2)
        lapply(unique(props_long[iso2 == .iso2]$quintile) %>% sort, function(.quintile) {
                print(.quintile)
                sapply(unique(props_long[iso2 == .iso2]$tech), function(.tech) {
                        print(.tech)
                        props_long[iso2 == .iso2 & 
                                           quintile == .quintile & 
                                           tech == .tech] %>%
                                nlsTechnology(
                                        max_penetration = max_penetration[iso2 == .iso2 & 
                                                                                  tech == .tech]$max_share,
                                        growth_rate = 0.1, 
                                        inflexion_year = 2025
                                )
                }, simplify = FALSE, USE.NAMES = TRUE)
        })
}, simplify = FALSE, USE.NAMES = TRUE)

# Plot results for a given country
plotCountry <- function(.iso2) {
        lapply(unique(props_long[iso2 == .iso2]$tech), function(.tech) {
                lapply(1:5, function(.quintile) {
                        data.table(year = 2000:2050, quintile = .quintile) %>%
                                mutate(
                                        predicted_share = predict(
                                                tech_penetration_fits[[.iso2]][[.quintile]][[.tech]],
                                                newdata = list(year = year)
                                        ),
                                        tech = .tech
                                )
                }) %>% rbindlist
        }) %>% rbindlist %>%
                mutate(iso2 = .iso2) %>%
                left_join(props_long, 
                          by = c('iso2', 'year', 'tech', 'quintile')) %>%
                mutate(quintile = str_c('Q', quintile)) %>%
                ggplot(aes(year, predicted_share, color = tech)) +
                geom_line() +
                geom_point(aes(year, share, color = tech), size = 1) +
                facet_grid(vars(quintile), vars(tech), switch = "y") +
                scale_y_continuous(labels = scales::label_percent()) +
                scale_x_continuous(breaks = seq(2000, 2050, by = 10)) +
                xlab('') + 
                ylab('Penetration rate') +
                ggtitle(countrycode(.iso2, 'iso2c', 'country.name')) +
                theme_minimal() +
                theme(legend.position = 'none',
                      text = element_text(size = 14))
}

# More robust function to extract NLS results
extract_nls_summary_robust <- function(model_list) {
        result_df <- data.frame()
        
        for(q_idx in seq_along(model_list)) {
                quintile_models <- model_list[[q_idx]]
                
                for(tech_name in names(quintile_models)) {
                        model <- quintile_models[[tech_name]]
                        
                        if(inherits(model, "nls")) {
                                tryCatch({
                                        # Just extract coefficients without standard errors
                                        coefs <- coef(model)
                                        
                                        temp_df <- data.frame(
                                                quintile = paste("Quintile", q_idx),
                                                technology = tech_name,
                                                parameter = names(coefs),
                                                estimate = unname(coefs)
                                        )
                                        
                                        result_df <- rbind(result_df, temp_df)
                                }, error = function(e) {
                                        warning(paste("Could not extract results for quintile", 
                                                      q_idx, "technology", tech_name))
                                })
                        }
                }
        }
        
        return(result_df)
}

# Function to create a formatted table for one country
create_country_table <- function(summary_df, country_name) {
        # Reshape the data to wide format
        summary_wide <- reshape2::dcast(
                summary_df,
                quintile + parameter ~ technology,
                value.var = "estimate"
        )
        
        # Print the results
        print(paste("Results for", country_name))
        print(summary_wide)
        
        return(summary_wide)
}

# Generate plots
plotCountry('DE')
plotCountry('GB')
plotCountry('US')

# Extract and display results for each country
DE_summary <- extract_nls_summary_robust(tech_penetration_fits[['DE']])
GB_summary <- extract_nls_summary_robust(tech_penetration_fits[['GB']])
US_summary <- extract_nls_summary_robust(tech_penetration_fits[['US']])

# Create tables
DE_table <- create_country_table(DE_summary, "Germany")
GB_table <- create_country_table(GB_summary, "United Kingdom")
US_table <- create_country_table(US_summary, "United States")

```
The one below I use for the paper. It removes hybrid in Germany and deals better with high saturation levels for smartphones. 
```{r s-curve take three, echo=FALSE}
# Configure maximum penetration hypothesis
max_penetration <- tribble(
        ~iso2, ~tech, ~max_share,
        # Germany
        'DE', 'solar', 0.95,
        'DE', 'smartphone', 1.0,
        'DE', 'skills', 0.8,
        'DE', 'internet', 1.0,
        'DE', 'hybrid', 1.0,
        'DE', 'commute', 0.3,
        'DE', 'fuel_switch', 0.45,
        'DE', 'renovation', 0.83,
        # US 
        'US', 'solar', 0.47,
        'US', 'smartphone', 1.0,
        'US', 'skills', 1.0,
        'US', 'internet', 1.0,
        'US', 'hybrid', 0.7,
        'US', 'commute', 0.5,
        'US', 'fuel_switch', 1.0,
        'US', 'renovation', 0.78,
        # GB 
        'GB', 'solar', 0.65,
        'GB', 'smartphone', 1.0,
        'GB', 'skills', 0.95,
        'GB', 'internet', 1.0,
        'GB', 'hybrid', 0.8,
        'GB', 'commute', 0.5,
        'GB', 'fuel_switch', 0.7,
        'GB', 'renovation', 0.80
) %>% as.data.table

# Create filtered version of props_long without German hybrid
props_long_filtered <- props_long %>%
    filter(!(iso2 == "DE" & tech == "hybrid"))

# Function to obtain a fit for a particular iso2 x technology x quintile triplet
nlsTechnology <- function(dt, max_penetration, growth_rate, inflexion_year) {
        .tech <- dt$tech[1]
        .quintile <- dt$quintile[1]
        .iso2 <- dt$iso2[1]
        
        country_max <- max_penetration

        # Handle smartphone saturation for US, UK, and DE
        if(.tech == "smartphone" && .iso2 %in% c("US", "GB", "DE") && min(dt$share) > 0.8) {
            if(.iso2 == "DE") {
                # Special handling for German smartphones
                growth_rate <- 0.3  # Faster growth
                inflexion_year <- 2005  # Earlier inflection
            } else {
                # US and UK handling
                growth_rate <- 0.2
                inflexion_year <- min(dt$year) - 5
            }
            # Use observed maximum as lower bound for all saturated cases
            country_max <- min(max(dt$share), country_max)
        }
        
        target_2050 <- tail(props_long_filtered[iso2 == .iso2 &
                                              quintile == .quintile &
                                              tech == .tech], 1)
        target_2050$year <- 2050
        target_2050$share <- country_max
        
        dt <- rbindlist(list(dt, target_2050))
        
        dt %>%
                minpack.lm::nlsLM(
                        share ~ country_max / (1 + exp(-growth_rate * (year - inflexion_year))),
                        .,
                        start = list(
                                country_max = country_max,
                                growth_rate = growth_rate,
                                inflexion_year = inflexion_year
                        ),
                        lower = c('country_max' = 0,
                                   'growth_rate' = 0,
                                   'inflexion_year' = 1980),
                        upper = c('country_max' = country_max,
                                   'growth_rate' = 0.15,
                                   'inflexion_year' = 2500),
                        control = nls.lm.control(maxfev = 4000, maxiter = 1024)
                )
}

# Market penetration fits across all countries, technologies and quintiles
tech_penetration_fits <- sapply(unique(props_long_filtered$iso2) %>% sort, function(.iso2) {
        print(.iso2)
        lapply(unique(props_long_filtered[iso2 == .iso2]$quintile) %>% sort, function(.quintile) {
                print(.quintile)
                sapply(unique(props_long_filtered[iso2 == .iso2]$tech), function(.tech) {
                        print(.tech)
                        props_long_filtered[iso2 == .iso2 &
                                            quintile == .quintile &
                                            tech == .tech] %>%
                                nlsTechnology(
                                        max_penetration = max_penetration[iso2 == .iso2 &
                                                                                   tech == .tech]$max_share,
                                        growth_rate = 0.1, 
                                        inflexion_year = 2025
                                )
                }, simplify = FALSE, USE.NAMES = TRUE)
        })
}, simplify = FALSE, USE.NAMES = TRUE)

# Plot results for a given country
plotCountry <- function(.iso2) {
        lapply(unique(props_long_filtered[iso2 == .iso2]$tech), function(.tech) {
                lapply(1:5, function(.quintile) {
                        data.table(year = 2000:2050, quintile = .quintile) %>%
                                mutate(
                                        predicted_share = predict(
                                                tech_penetration_fits[[.iso2]][[.quintile]][[.tech]],
                                                newdata = list(year = year)
                                        ),
                                        tech = .tech
                                )
                }) %>% rbindlist
        }) %>% rbindlist %>%
                mutate(iso2 = .iso2) %>%
                left_join(props_long_filtered,
                           by = c('iso2', 'year', 'tech', 'quintile')) %>%
                mutate(quintile = str_c('Q', quintile)) %>%
                ggplot(aes(year, predicted_share, color = tech)) +
                geom_line() +
                geom_point(aes(year, share, color = tech), size = 1) +
                facet_grid(vars(quintile), vars(tech), switch = "y") +
                scale_y_continuous(labels = scales::label_percent()) +
                scale_x_continuous(breaks = seq(2000, 2050, by = 10)) +
                xlab('') + 
                ylab('Penetration rate') +
                ggtitle(countrycode(.iso2, 'iso2c', 'country.name')) +
                theme_minimal() +
                theme(legend.position = 'none',
                      text = element_text(size = 14))
}

# More robust function to extract NLS results
extract_nls_summary_robust <- function(model_list) {
        result_df <- data.frame()
        
        for(q_idx in seq_along(model_list)) {
                quintile_models <- model_list[[q_idx]]
                
                for(tech_name in names(quintile_models)) {
                        model <- quintile_models[[tech_name]]
                        
                        if(inherits(model, "nls")) {
                                tryCatch({
                                        # Just extract coefficients without standard errors
                                        coefs <- coef(model)
                                        
                                        temp_df <- data.frame(
                                                quintile = paste("Quintile", q_idx),
                                                technology = tech_name,
                                                parameter = names(coefs),
                                                estimate = unname(coefs)
                                        )
                                        
                                        result_df <- rbind(result_df, temp_df)
                                }, error = function(e) {
                                        warning(paste("Could not extract results for quintile",
                                                       q_idx, "technology", tech_name))
                                })
                        }
                }
        }
        
        return(result_df)
}

# Function to create a formatted table for one country
create_country_table <- function(summary_df, country_name) {
        # Reshape the data to wide format
        summary_wide <- reshape2::dcast(
                summary_df,
                quintile + parameter ~ technology,
                value.var = "estimate"
        )
        
        # Print the results
        print(paste("Results for", country_name))
        print(summary_wide)
        
        return(summary_wide)
}

# Generate plots
plotCountry('DE')
plotCountry('GB')
plotCountry('US')

# Extract and display results for each country
DE_summary <- extract_nls_summary_robust(tech_penetration_fits[['DE']])
GB_summary <- extract_nls_summary_robust(tech_penetration_fits[['GB']])
US_summary <- extract_nls_summary_robust(tech_penetration_fits[['US']])

# Create tables
DE_table <- create_country_table(DE_summary, "Germany")
GB_table <- create_country_table(GB_summary, "United Kingdom")
US_table <- create_country_table(US_summary, "United States")

```

```{r model summary, echo = FALSE}
# Function to create table for one country
create_country_table <- function(country_summary, country_name) {
  library(dplyr)
  library(tidyr)
  library(kableExtra)
  
  # Format table
  pub_table <- country_summary %>%
    # Round estimates to 3 decimal places
    mutate(
      estimate = round(estimate, 3)
    ) %>%
    # Pivot wider to get technologies as columns
    pivot_wider(
      id_cols = c(quintile, parameter),
      names_from = technology,
      values_from = estimate
    ) %>%
    # Arrange by parameter and quintile
    arrange(parameter, quintile)
  
  # Create formatted table
  formatted_table <- pub_table %>%
    kbl(format = "html",
        caption = paste("NLS Regression Results for", country_name),
        align = "c",
        escape = FALSE) %>%
    kable_styling(bootstrap_options = c("striped", "hover"),
                  full_width = FALSE) %>%
    # Group by parameters instead of countries
    pack_rows(index = table(pub_table$parameter)) %>%
    add_header_above(c("Quintile Groups" = 2, 
                      "Technologies" = ncol(pub_table) - 2)) %>%
    footnote(
      general = paste("Note: Values show parameter estimates from NLS regression.",
                     "Parameters shown are country_max (maximum penetration),",
                     "growth_rate (speed of adoption), and",
                     "inflexion_year (year of maximum growth).")
    )
  
  return(formatted_table)
}

# Create separate tables for each country
germany_table <- create_country_table(DE_summary, "Germany")
uk_table <- create_country_table(GB_summary, "United Kingdom")
us_table <- create_country_table(US_summary, "United States")

# Return all tables
list(
  germany = germany_table,
  uk = uk_table,
  us = us_table
)

```

## Logistic on full dataset 

Compare logistic on summary data with full dataset at household level. 

```{r data preparation for household, echo=FALSE}
deu_uptake <- DEU %>%
  # Create binary indicators for each technology
  mutate(
    # Hybrid/EV ownership
    hybrid_owned = case_when(
      hli0121 == 1 | hli0122 == 1 | hli0123 == 1 | hli0124 == 1 | 
      hli0128 == 1 | hli0129 == 1 | hli0130 == 1 | hli0131 == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Solar panel ownership
    solar_owned = case_when(
      hgeqpsol == 1 | hgeqpnrj == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Renovation status
    renovation_done = case_when(
      hgcondit == 2 | hgcondit == 3 ~ 1,
      TRUE ~ 0
    ),
    
    # Smartphone ownership (with year condition)
    smartphone_owned = case_when(
      year > 2015 ~ 1,
      hgeqptel == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Internet access
    internet_access = case_when(
      year == 2020 ~ NA_real_,  # Different methodology in 2020
      hlf0178_h == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Fuel switch (with year condition)
    fuel_switch = case_when(
      year >= 2016 & energy_combination == 3 ~ 1,
      year >= 2016 ~ 0,
      TRUE ~ NA_real_
    ),
    
    # Create quintile from weighted_decile
    quintile = ceiling(weighted_decile/2)
  ) %>%
  # Select only necessary columns
  dplyr::select(
    hid,        # Household ID
    year,
    weighted_decile,
    quintile,
    hybrid_owned,
    solar_owned,
    renovation_done,
    smartphone_owned,
    internet_access,
    fuel_switch,
    # Add any other control variables you'd like to include
    hh_incomey,  # household income
    hgowner,     # homeownership status
    hgtyp1hh,    # household type
    pop,
    weight
  )

### US 

us_uptake <- US %>%
  # Create binary indicators for each technology
  mutate(
    # Hybrid/EV ownership
    hybrid_owned = case_when(
      hybrid == 1 | hybrid_2 == 1 | hybrid_3 == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Solar heating
    solar_owned = case_when(
      heat_method == 6 | heat_method_2 == 6 | heat_method_3 == 6 ~ 1,
      TRUE ~ 0
    ),
    
    # Home repairs/renovation
    renovation_done = case_when(
      hh_repair > 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Smartphone ownership
    smartphone_owned = case_when(
      smartphone == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Internet access (computer ownership)
    internet_access = case_when(
      computer == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Internet skills
    internet_skills = case_when(
      internet == 1 ~ 1,
      TRUE ~ 0
    ),
    
    # Fuel switch (electric heating as primary with only electric or solar as secondary)
    fuel_switch = case_when(
      heat_method == 2 & 
      (heat_method_2 == 0 | heat_method_2 == 2 | heat_method_2 == 6) &
      (heat_method_3 == 0 | heat_method_3 == 2 | heat_method_3 == 6) ~ 1,
      TRUE ~ 0
    ),
    
    # Create quintile from weighted_decile
    quintile = ceiling(weighted_decile/2)
  ) %>%
  # Filter years as in your summary
  filter(year > 2010) %>%
  # Select only necessary columns
  dplyr::select(
    pid,                # Personal/Household ID
    year,
    weighted_decile,
    quintile,
    hybrid_owned,
    solar_owned,
    renovation_done,
    smartphone_owned,
    internet_access,
    internet_skills,
    fuel_switch,
    # Control variables with correct names
    hh_income,          # Household income
    hh_own,            # Home ownership
    hh_size,           # Household size
    weight             # Survey weight
  )

uk_uptake <- UK %>%
  # Create binary indicators for each technology
  mutate(
    # Solar panel ownership
    solar_owned = case_when(
      solar1 %in% c("yes - fitted", "Yes - fitted") |
      solar2 %in% c("yes - fitted", "Yes - fitted") |
      solar3 %in% c("yes - fitted", "Yes - fitted") ~ 1,
      TRUE ~ 0
    ),
    
    # Hybrid/EV ownership
    hybrid_owned = case_when(
      carfuel1 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") |
      carfuel2 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") |
      carfuel3 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") |
      carfuel4 %in% c("Electric / battery", "electric / battery", "Hybrid (petrol/electric)", "hybrid (petrol/electric)") ~ 1,
      TRUE ~ 0
    ),
    
    # Smartphone ownership
    smartphone_owned = case_when(
      smartmob %in% c("Yes", "yes") ~ 1,
      TRUE ~ 0
    ),
    
    # Internet skills (daily usage)
    internet_skills = case_when(
      netpuse %in% c("Every day", "every day") | 
      netpusenew %in% c("Every day", "every day") ~ 1,
      TRUE ~ 0
    ),
    
    # Internet access
    internet_access = case_when(
      pcnet %in% c("yes", "Yes") ~ 1,
      TRUE ~ 0
    ),
    
    # Sustainable commuting
    sustainable_commute = case_when(
      year < 2018 ~ case_when(
        worktrav %in% c(
          "Bus/coach", "bus/coach", "Cycle", "cycle", "Walk", "walk",
          "Train", "train", "Underground/Metro/Tram/Light railway",
          "underground/metro/tram/light railway",
          "underground/metro/tram/light railway (if england/scotland/wales)",
          "underground/metro/tram/light railway {if region = gb}",
          "Motorcycle/moped/scooter", "motorcycle/moped/scooter"
        ) ~ 1,
        TRUE ~ 0
      ),
      year >= 2018 ~ case_when(
        wktrv10 == "Yes mentioned" |  # Underground/metro
        wktrv6 == "Yes mentioned" |   # Bus
        wktrv7 == "Yes mentioned" |   # Train
        wktrv9 == "Yes mentioned" |   # Walk
        wktrv8 == "Yes mentioned" ~ 1,  # Cycle
        TRUE ~ 0
      )
    ),
    
    # Fuel switch (electric only)
    fuel_switch = case_when(
      xpelecy > 0 & 
      (xpgasy <= 0 | is.na(xpgasy)) & 
      (xpoily <= 0 | is.na(xpoily)) ~ 1,
      TRUE ~ 0
    ),
    
    # Create quintile from weighted_decile
    quintile = ceiling(weighted_decile/2)
  ) %>%
  # Select only necessary columns
  dplyr::select(
    pidp,               # Personal ID
    hidp,               # Household ID
    year,
    weighted_decile,
    quintile,
    hybrid_owned,
    solar_owned,
    smartphone_owned,
    internet_access,
    internet_skills,
    sustainable_commute,
    fuel_switch,
    # Control variables
    hh_incomey,         # Household income
    hsownd,             # Home ownership
    hhsize,             # Household size
    hhdenui_xw          # Survey weight
  )

```
```{r logistic on full data, echo=FALSE}
nlsTechnologyHousehold <- function(dt, tech_name, iso2, quintile) {
  # Get max penetration (2050 target) for this technology and country
  max_pen <- max_penetration %>% 
    filter(iso2 == !!iso2, tech == !!tech_name) %>% 
    pull(max_share)
  
  # Calculate current adoption rates by year for this quintile
  current_data <- dt %>%
    filter(!is.na(adoption), quintile == !!quintile) %>%
    group_by(year) %>%
    summarize(share = mean(adoption, na.rm = TRUE))
  
  # Add 2050 target point
  target_2050 <- data.frame(
    year = 2050,
    share = max_pen
  )
  
  # Combine current data with target
  model_data <- bind_rows(current_data, target_2050)
  
  tryCatch({
    minpack.lm::nlsLM(
      share ~ max_pen / (1 + exp(-growth_rate * (year - inflexion_year))),
      data = model_data,
      start = list(
        growth_rate = 0.1,
        inflexion_year = 2025
      ),
      lower = c(
        'growth_rate' = 0,
        'inflexion_year' = 1980
      ),
      upper = c(
        'growth_rate' = 0.3,
        'inflexion_year' = 2500
      ),
      control = nls.lm.control(maxfev = 8000, maxiter = 2048)
    )
  }, error = function(e) {
    warning(paste("Failed to fit model for:", tech_name, "in", iso2, 
                 "quintile:", quintile, "\nError:", e$message))
    return(NULL)
  })
}

# Function to fit all quintiles for a technology
fitTechnologyByQuintile <- function(uptake_data, tech_col, tech_name, iso2) {
  fits <- lapply(1:5, function(q) {
    model_data <- uptake_data %>%
      rename(adoption = !!tech_col)
    
    nlsTechnologyHousehold(model_data, tech_name, iso2, q)
  })
  names(fits) <- paste0("Q", 1:5)
  return(fits)
}

# Function to plot the results
plotTechnologyFits <- function(fits, uptake_data, tech_col, tech_name, iso2) {
  # Get actual data
  actual_data <- uptake_data %>%
    group_by(year, quintile) %>%
    summarize(actual = mean(!!sym(tech_col), na.rm = TRUE))
  
  # Create prediction data
  years <- seq(min(uptake_data$year), 2050, by = 1)
  
  # Get predictions for each quintile
  pred_data <- lapply(1:5, function(q) {
    model <- fits[[paste0("Q", q)]]
    if(is.null(model)) return(NULL)
    
    max_pen <- max_penetration %>% 
      filter(iso2 == !!iso2, tech == !!tech_name) %>% 
      pull(max_share)
    
    data.frame(
      year = years,
      quintile = q,
      predicted = max_pen / (1 + exp(-coef(model)["growth_rate"] * 
                                    (years - coef(model)["inflexion_year"])))
    )
  }) %>% bind_rows()
  
  # Create plot
  ggplot() +
    geom_line(data = pred_data, aes(x = year, y = predicted, color = factor(quintile))) +
    geom_point(data = actual_data, aes(x = year, y = actual, color = factor(quintile))) +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = paste(tech_name, "adoption in", iso2),
         y = "Adoption rate",
         x = "Year",
         color = "Income Quintile") +
    theme_minimal()
}

# Example usage for solar in Germany:
solar_fits_de <- fitTechnologyByQuintile(deu_uptake, "solar_owned", "solar", "DE")
plotTechnologyFits(solar_fits_de, deu_uptake, "solar_owned", "solar", "DE")

```

```{r s curve visualization, echo = FALSE}
# Function to fit S-curves to household-level data
nlsTechnologyHousehold <- function(dt, tech_name, iso2, quintile) {
  # Get max penetration (2050 target) for this technology and country
  max_pen <- max_penetration %>% 
    filter(iso2 == !!iso2, tech == !!tech_name) %>% 
    pull(max_share)
  
  # Calculate current adoption rates by year for this quintile
  current_data <- dt %>%
    filter(!is.na(adoption), quintile == !!quintile) %>%
    group_by(year) %>%
    summarize(share = mean(adoption, na.rm = TRUE))
  
  # Add 2050 target point
  target_2050 <- data.frame(
    year = 2050,
    share = max_pen
  )
  
  # Combine current data with target
  model_data <- bind_rows(current_data, target_2050)
  
  tryCatch({
    minpack.lm::nlsLM(
      share ~ max_pen / (1 + exp(-growth_rate * (year - inflexion_year))),
      data = model_data,
      start = list(
        growth_rate = 0.1,
        inflexion_year = 2025
      ),
      lower = c(
        'growth_rate' = 0,
        'inflexion_year' = 1980
      ),
      upper = c(
        'growth_rate' = 0.3,
        'inflexion_year' = 2500
      ),
      control = nls.lm.control(maxfev = 8000, maxiter = 2048)
    )
  }, error = function(e) {
    warning(paste("Failed to fit model for:", tech_name, "in", iso2, 
                 "quintile:", quintile, "\nError:", e$message))
    return(NULL)
  })
}

# Function to fit all quintiles for a technology
fitTechnologyByQuintile <- function(uptake_data, tech_col, tech_name, iso2) {
  fits <- lapply(1:5, function(q) {
    model_data <- uptake_data %>%
      rename(adoption = !!tech_col)
    
    nlsTechnologyHousehold(model_data, tech_name, iso2, q)
  })
  names(fits) <- paste0("Q", 1:5)
  return(fits)
}

# Function to plot the results
plotTechnologyFits <- function(fits, uptake_data, tech_col, tech_name, iso2) {
  # Get actual data
  actual_data <- uptake_data %>%
    group_by(year, quintile) %>%
    summarize(actual = mean(!!sym(tech_col), na.rm = TRUE), .groups = "drop")
  
  # Create prediction data
  years <- seq(min(uptake_data$year), 2050, by = 1)
  
  # Get predictions for each quintile
  pred_data <- lapply(1:5, function(q) {
    model <- fits[[paste0("Q", q)]]
    if(is.null(model)) return(NULL)
    
    max_pen <- max_penetration %>% 
      filter(iso2 == !!iso2, tech == !!tech_name) %>% 
      pull(max_share)
    
    data.frame(
      year = years,
      quintile = q,
      predicted = max_pen / (1 + exp(-coef(model)["growth_rate"] * 
                                    (years - coef(model)["inflexion_year"])))
    )
  }) %>% bind_rows()
  
  # Create plot
  ggplot() +
    geom_line(data = pred_data, aes(x = year, y = predicted, color = factor(quintile))) +
    geom_point(data = actual_data, aes(x = year, y = actual, color = factor(quintile))) +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = paste(tech_name, "adoption in", iso2),
         y = "Adoption rate",
         x = "Year",
         color = "Income Quintile") +
    theme_minimal()
}

# Function to extract coefficients from fits
extract_coefficients <- function(fits, tech_name, iso2) {
  lapply(1:5, function(q) {
    model <- fits[[paste0("Q", q)]]
    if(!is.null(model)) {
      data.frame(
        technology = tech_name,
        country = iso2,
        quintile = q,
        growth_rate = coef(model)["growth_rate"],
        inflexion_year = coef(model)["inflexion_year"]
      )
    }
  }) %>% bind_rows()
}

# Modified fit_and_plot_all function
fit_and_plot_all <- function(uptake_data, technologies, iso2, output_dir = "plots") {
  # Create output directory if it doesn't exist
  dir.create(output_dir, showWarnings = FALSE)
  
  # Store all coefficients
  all_coefficients <- data.frame()
  
  # Create plots for each technology
  for(tech_name in names(technologies)) {
    tech_col <- technologies[[tech_name]]
    
    # Check if this technology-country combination exists in max_penetration
    if(nrow(max_penetration %>% filter(iso2 == !!iso2, tech == tech_name)) == 0) {
      warning(paste("No max penetration target found for", tech_name, "in", iso2))
      next
    }
    
    # Check if column exists in dataset
    if(!(tech_col %in% names(uptake_data))) {
      warning(paste("Column", tech_col, "not found in dataset for", iso2))
      next
    }
    
    # Fit models
    fits <- fitTechnologyByQuintile(uptake_data, tech_col, tech_name, iso2)
    
    # Create and save plot
    p <- plotTechnologyFits(fits, uptake_data, tech_col, tech_name, iso2)
    ggsave(file.path(output_dir, paste0(iso2, "_", tech_name, "_fits.png")), p, width = 10, height = 6)
    
    # Extract coefficients
    coeffs <- extract_coefficients(fits, tech_name, iso2)
    all_coefficients <- bind_rows(all_coefficients, coeffs)
  }
  
  return(all_coefficients)
}

# Define technology lists for each country
de_technologies <- list(
  solar = "solar_owned",
  hybrid = "hybrid_owned",
  smartphone = "smartphone_owned",
  internet = "internet_access",
  renovation = "renovation_done",
  fuel = "fuel_switch"
)

us_technologies <- list(
  solar = "solar_owned",
  hybrid = "hybrid_owned",
  smartphone = "smartphone_owned",
  internet = "internet_access",
  skills = "internet_skills",
  renovation = "renovation_done",
  fuel = "fuel_switch"
)

uk_technologies <- list(
  solar = "solar_owned",
  hybrid = "hybrid_owned",
  smartphone = "smartphone_owned",
  internet = "internet_access",
  skills = "internet_skills",
  commute = "sustainable_commute",
  fuel = "fuel_switch"
)

# Run analysis for each country
de_coefficients <- fit_and_plot_all(deu_uptake, de_technologies, "DE")
us_coefficients <- fit_and_plot_all(us_uptake, us_technologies, "US")
uk_coefficients <- fit_and_plot_all(uk_uptake, uk_technologies, "GB")

# Combine all coefficients
all_coefficients <- bind_rows(de_coefficients, us_coefficients, uk_coefficients)

# Create summary tables
summary_table <- all_coefficients %>%
  group_by(country, technology) %>%
  summarize(
    avg_growth_rate = mean(growth_rate, na.rm = TRUE),
    min_growth_rate = min(growth_rate, na.rm = TRUE),
    max_growth_rate = max(growth_rate, na.rm = TRUE),
    avg_inflexion_year = mean(inflexion_year, na.rm = TRUE),
    growth_inequality = max_growth_rate - min_growth_rate,
    .groups = "drop"
  ) %>%
  arrange(country, technology)

# Create a heatmap of growth rates
ggplot(all_coefficients, aes(x = factor(quintile), y = paste(country, technology), fill = growth_rate)) +
  geom_tile() +
  scale_fill_viridis_c() +
  labs(x = "Income Quintile", y = "", fill = "Growth Rate") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 8))

# Print summary table
print(summary_table)

```

## Step 3: 2050 Diffusion Impacts

Step 3 Estimate how distributional impacts of technology uptake affect final energy costs for household across time. Use survey data to estimate how final energy costs increase/decrease with different technologies including in a household (holding all other variables constant) in 2020. Then, hold energy prices static (very large assumption) to see how technology diffusion affects final energy costs for residential sector at decile level in 2050.

I first get the average amount spent on energy, then roughly estimate how much is on gas vs electric, then get historical prices and convert amount spent to gas and eelctric to consumption. This is easier for some data (ex. US ) than others 

take a simple model to turn the technology into electricity 
```{r energy data, echo=FALSE}

# IEA Household Final Annual Average -- USD/MWh 
us_prices <- tibble(
  country = "US",
  year = 2011:2021,
  elec_price = c(117.169, 118.785, 121.237, 125.179, 126.513, 125.489, 128.871, 128.693, 130.144, 131.959, 137.237),  # UDD per MWh
  gas_price = c(36.415, 35.322, 34.02, 36.134, 34.233, 33.166, 35.874, 34.555, 34.542, 35.773, 40.532)
)



# IEA USD/ KwH in PPP
deu_prices <- tibble(
  country = "DEU",
  year = 2011:2021,
  elec_price = c(320.702, 334.775, 376.879, 387.223, 378.925, 395.026, 409.247, 407.031, 397.152, 409.629, 439.238),  
  gas_price = c(84.405, 89.26, 91.983, 92.8, 90.775, 91.197, 89.122, 88.807, 90.435, 92.317, 97.579)
)


# IEA Household EPT FD
uk_prices <- tibble(
  country = "UK",
  year = 2011:2021,
  elec_price = c(184.896, 195.878, 211.692, 220.36, 217.323, 218.736, 232.745, 249.677, 272.748, 276.079, 303.6),  
  gas_price = c(59.501, 64.918, 69.562, 73.303, 69.636, 64.073, 62.914, 64.889, 66.345, 60.626, 62.688)

)



# Combine all data
historical_prices <- bind_rows(
  us_prices,
  deu_prices,
  uk_prices
)

# Function to merge historical prices with country-specific datasets
merge_prices <- function(country_data, country_name) {
  country_data %>%
    left_join(
      historical_prices %>% filter(country == country_name),
      by = "year"
    )
}

# Create visualizations for available data
create_price_plot <- function(data) {
  ggplot(data %>% filter(!is.na(elec_price)), aes(x = year, color = country)) +
    geom_line(aes(y = elec_price, linetype = "Electricity"), size = 1) +
    geom_line(aes(y = gas_price, linetype = "Natural Gas"), size = 1) +
    facet_wrap(~country, scales = "free_y") +
    theme_minimal() +
    labs(
      title = "Historical Energy Prices (2011-2021)",
      subtitle = "By Country USD/MWh",
      y = "Price",
      color = "Country",
      linetype = "Energy Type",
      caption = "Sources: IEA Energy Price Data Household Final Residential (2011-2021)"
    ) +
    scale_color_manual(values = c("US" = "blue", "DEU" = "red", "UK" = "green")) +
    theme(
      legend.position = "bottom",
      strip.text = element_text(size = 12, face = "bold")
    )
}

# Function to print data summary with source documentation
print_summary <- function(data) {
  for (country_name in unique(data$country)) {
    country_data <- data %>% 
      filter(country == country_name, !is.na(elec_price))
    
    if (nrow(country_data) > 0) {
      cat(sprintf("\nSummary for %s:\n", country_name))
      print(summary(country_data[c("elec_price", "gas_price")]))
      cat("Data source: ", switch(country_name,
                                "US" = "IEA",
                                "DEU" = "IEA",
                                "UK" = "IEA"),
          "\n")
    }
  }
}

historical_prices <- bind_rows(us_prices, deu_prices, uk_prices)
price_plot <- create_price_plot(historical_prices)
print_summary(historical_prices)
print(price_plot)
```

Now that we have average historical costs, I can convert the amount spent to consumption at decile level. 
```{r consumption creation, echo=FALSE}

energy_US <- US %>%
  group_by(year, decile) %>%
  summarise(
    avg_elec_exp = mean(elec_a_exp, na.rm = TRUE),
    avg_gas_exp = mean(gas_a_exp, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(year, decile) %>%
  mutate(country = "US")

energy_UK <- UK %>%
  group_by(year, decile) %>%
  summarise(
    avg_elec_exp = mean(xpelecy, na.rm = TRUE),
    avg_gas_exp = mean(xpgasy, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(year, decile)

energy_DEU <- DEU %>%
  mutate(hgheat = ifelse(hgheat < 0, NA, hgheat)) %>%
  group_by(year, decile) %>%
  filter(year != 2015) %>%
  summarise(
    avg_elec_exp = 12 * mean(hgelectr, na.rm = TRUE),
    avg_gas_exp = 12 * mean(hgheat, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(year, decile)

### exchange rate for Germany and UK 
# EUR/USD exchange rate for Germany
getSymbols("DEXUSEU", src = "FRED")
eur_exchange_data <- data.frame(date = index(DEXUSEU), rate = as.numeric(DEXUSEU[, 1]))
eur_exchange_data$year <- format(eur_exchange_data$date, "%Y")
eur_avg_rate <- eur_exchange_data %>%
  group_by(year) %>%
  summarise(avg_rate = mean(rate, na.rm = TRUE))
eur_avg_rate$year <- as.numeric(eur_avg_rate$year)

# Apply EUR/USD rate to German data
energy_DEU <- energy_DEU %>%
  left_join(eur_avg_rate, by = "year") %>%
  mutate(
    avg_elec_exp_usd = avg_elec_exp * avg_rate,  # Convert EUR to USD
    avg_gas_exp_usd = avg_gas_exp * avg_rate      
  )

# GBP/USD exchange rate for UK
getSymbols("DEXUSUK", src = "FRED")
gbp_exchange_data <- data.frame(date = index(DEXUSUK), rate = as.numeric(DEXUSUK[, 1]))
gbp_exchange_data$year <- format(gbp_exchange_data$date, "%Y")
gbp_avg_rate <- gbp_exchange_data %>%
  group_by(year) %>%
  summarise(avg_rate = mean(rate, na.rm = TRUE))
gbp_avg_rate$year <- as.numeric(gbp_avg_rate$year)

# Apply GBP/USD rate to UK data
energy_UK <- energy_UK %>%
  left_join(gbp_avg_rate, by = "year") %>%
  mutate(
    avg_elec_exp_usd = avg_elec_exp * avg_rate,  # Convert GBP to USD
    avg_gas_exp_usd = avg_gas_exp * avg_rate      
  )

energy_DEU_2 <- energy_DEU %>%
  dplyr::select(year, decile, avg_elec_exp_usd, avg_gas_exp_usd) %>%
  rename(
    avg_elec_exp = avg_elec_exp_usd,  
    avg_gas_exp = avg_gas_exp_usd
  ) %>%
  mutate(country = "DEU")

energy_UK_2 <- energy_UK %>%
  dplyr::select(year, decile, avg_elec_exp_usd, avg_gas_exp_usd) %>%
  rename(
    avg_elec_exp = avg_elec_exp_usd,  
    avg_gas_exp = avg_gas_exp_usd
  ) %>%
  mutate(country = "UK")

energy_combined <- bind_rows(energy_DEU_2, energy_US, energy_UK_2) %>%
  left_join(historical_prices, by = c("year", "country")) %>%
  mutate(gas_consumption = avg_gas_exp / (gas_price),
         elec_consumption = avg_elec_exp / (elec_price))


energy_combined_long <- energy_combined %>%
  pivot_longer(
    cols = c(gas_consumption, elec_consumption),
    names_to = "type",
    values_to = "consumption"
  )

# Create the plot
ggplot(energy_combined_long, aes(x = year, y = consumption, color = type)) +
  geom_line(aes(group = interaction(type, decile))) +
  facet_grid(country ~ decile, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Energy Consumption Over Time by Country and Decile",
    y = "Consumption (MWh)",
    x = "Year"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


energy_combined_long %>%
  filter(country == "DEU") %>%
  ggplot(aes(x = year, y = consumption, color = type)) +
  geom_line(aes(group = interaction(type, decile))) +
  facet_wrap(~decile, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "German Energy Consumption Over Time by Decile",
    y = "Consumption (MWh)",
    x = "Year"
  )

```
US had a huge price increase in 2021 for gas. Overall downward trend for consumption. 
### Technology model for electricity 

```{r technology consumption, echo=FALSE}
technology_consumption <- data.frame(
  technology = c(
    "Owns a Smartphone",     # Daily charging
    "Hybrid/EV",            # EV charging
    "Solar Panels",         # (negative consumption/production)
    "Internet access",      # Router + devices
    "Home Renovations",     # Efficiency improvements
    "Digital Skills",       # Computer usage
    "Clean Heating Switch", # Moving from gas to electric heating
    "Sustainable Transport" # Public transport/biking
  ),
  kwh_per_year = c(
    30,      # Smartphone: daily charging
    2000,    # EV: annual charging for average use
    -3000,   # Solar: annual production
    180,     # Internet: router (~150 kWh) + device charging
    -500,    # Home renovations: efficiency savings
    250,     # Digital Skills: computer usage
    3500,    # Moving from gas to electric heating (increases electricity use)
    -200     # Sustainable transport: reduced car usage
  )
)

print(technology_consumption)

```

```{r combine with forecast, echo=FALSE}

elec_prices_2021 <- energy_combined %>%
  filter(year == 2021) %>%
  dplyr::select(country, elec_price) %>%
  distinct() %>%
  mutate(country = case_when(
    country == "DEU" ~ "Germany",
    TRUE ~ country
  ))

calculate_additional_demand <- function(forecasts_by_country, technology_consumption, elec_prices_2021) {
  additional_demand <- list()
  
  for(country in names(forecasts_by_country)) {
    cat("Processing country:", country, "\n")
    country_forecasts <- forecasts_by_country[[country]]
    
    elec_price <- elec_prices_2021$elec_price[elec_prices_2021$country == country] / 100
    
    if(length(elec_price) == 0) {
      cat("Warning: No electricity price found for", country, "\n")
      next
    }
    
    for(tech in names(country_forecasts)) {
      cat("Processing technology:", tech, "\n")
      tech_impact <- technology_consumption$kwh_per_year[technology_consumption$technology == tech]
      
      if(length(tech_impact) == 0) {
        cat("Warning: No technology impact found for", tech, "\n")
        next
      }
      
      decile_forecasts <- country_forecasts[[tech]]
      
      for(decile_forecast in decile_forecasts) {
        if(is.null(decile_forecast) || nrow(decile_forecast$predictions) == 0) next
        
        additional_cost <- decile_forecast$predictions %>%
          mutate(
            adoption_rate = predicted_adoption / 100,
            additional_kwh = adoption_rate * tech_impact,
            additional_cost = additional_kwh * elec_price,
            technology = tech,
            country = country
          )
        
        additional_demand[[paste(country, tech, decile_forecast$predictions$decile[1])]] <- additional_cost
      }
    }
  }
  
  result <- bind_rows(additional_demand)
  cat("Final number of rows:", nrow(result), "\n")
  return(result)
}

additional_demand <- calculate_additional_demand(forecasts_by_country, technology_consumption, elec_prices_2021)

```
Visualize the additional demand from technologies with our demand increase projections. 

```{r visualize additional costs, echo=FALSE}

# Create total_impact from additional_demand
total_impact <- additional_demand %>%
  filter(year >= 2021) %>%
  group_by(year, country, decile) %>%
  summarise(
    total_additional_cost = sum(additional_cost),
    .groups = 'drop'
  )

# Create a more informative plot
ggplot(total_impact, 
       aes(x = year, y = total_additional_cost, color = factor(decile))) +
  geom_line() +
  facet_wrap(~country, scales = "free_y") +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  labs(
    title = "Net Change in Annual Electricity Costs from Technology Adoption",
    subtitle = "Negative values indicate cost savings from solar generation and efficiency improvements",
    y = "Net Change in Electricity Costs (USD)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(
    legend.position = "bottom",
    plot.subtitle = element_text(size = 10)
  )

# Let's also show the technology breakdown to better understand the components
ggplot(additional_demand, 
       aes(x = year, y = additional_cost, fill = technology)) +
  geom_area(position = "stack") +
  facet_wrap(~country, scales = "free_y") +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  labs(
    title = "Components of Electricity Cost Changes",
    subtitle = "Showing contribution of each technology to total cost change",
    y = "Cost Impact (USD)",
    x = "Year",
    fill = "Technology"
  ) +
  theme(legend.position = "bottom")
```

#Step 4: Adoption S-curve impacts

I now have estimates of how much these additional technologies would cost each decile to 2050. Now it is time to run a better forecast model that assumes earlier or later adoption trends of technologies. I want to look at how earlier or later adoption affects. 

```{r fast and slow adoption, echo=FALSE}
starting_values <- combined_growth %>%
  group_by(technology, decile, country) %>%
  slice_max(end_year, n = 1) %>%
  dplyr::select(technology, decile, end_value, country, end_year)

print("Checking starting values:")
print(starting_values %>% arrange(technology, country, decile))


# Enhanced s-curve function with decile variation
create_adoption_curve <- function(
  technology, 
  decile,
  country,
  start_year = 2021,
  end_year = 2050,
  start_value,
  scenario = "conservative",
  max_adoption = NULL  # Will vary by technology and decile
) {
  
  # Define maximum adoption rates by technology and decile
  # Higher deciles generally have higher maximum adoption
  base_max <- case_when(
    technology == "Hybrid/EV" ~ 80,
    technology == "Solar Panels" ~ 40,
    technology == "Internet access" ~ 100,
    technology == "Owns a Smartphone" ~ 100,
    technology == "Digital Skills" ~ 90,
    technology == "Clean Heating Switch" ~ 70,
    technology == "Home Renovations" ~ 60,
    technology == "Sustainable Transport" ~ 50,
    TRUE ~ 100
  )
  
  # Adjust max adoption by decile
  decile_adjustment <- (decile - 5.5) * 5  # Deciles 1-10 get -22.5 to +22.5 adjustment
  
  # If max_adoption not specified, calculate it
  if(is.null(max_adoption)) {
    max_adoption <- min(100, base_max + decile_adjustment)
  }
  
  # Set growth rate and midpoint based on scenario
  if(scenario == "aggressive") {
    k <- 0.15 + (decile/100)  # Higher deciles adopt slightly faster
    midpoint <- 2035 - (decile/10)  # Higher deciles reach midpoint earlier
  } else {  # conservative
    k <- 0.08 + (decile/200)
    midpoint <- 2040 - (decile/20)
  }
  
  # Generate years
  years <- start_year:end_year
  
  # Ensure start_value doesn't exceed max_adoption
  start_value <- min(start_value, max_adoption)
  
  # Calculate shift parameter to match start_value
  shift <- -log((max_adoption/start_value) - 1) / k
  
  # Calculate adoption for each year
  adoption <- tibble(
    year = years,
    adoption = max_adoption / (1 + exp(-k * (years - midpoint))),
    decile = decile,
    technology = technology,
    country = country,
    scenario = scenario
  )
  
  return(adoption)
}

# Generate curves for all technologies and deciles
adoption_curves <- map_dfr(
  1:nrow(starting_values),
  function(i) {
    row <- starting_values[i,]
    
    # Generate both conservative and aggressive scenarios
    bind_rows(
      create_adoption_curve(
        technology = row$technology,
        decile = row$decile,
        country = row$country,
        start_value = row$end_value,
        scenario = "conservative"
      ),
      create_adoption_curve(
        technology = row$technology,
        decile = row$decile,
        country = row$country,
        start_value = row$end_value,
        scenario = "aggressive"
      )
    )
  }
)

ggplot(adoption_curves, 
       aes(x = year, y = adoption, color = factor(decile))) +
  geom_line() +
  facet_grid(country + scenario ~ technology) +  # Added country to faceting
  theme_minimal() +
  labs(
    title = "Technology Adoption Curves by Income Decile and Country",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(legend.position = "bottom")

ggplot(
  adoption_curves %>% filter(country == "UK"),
  aes(x = year, y = adoption, color = factor(decile))
) +
  geom_line() +
  facet_grid(scenario ~ technology) +
  theme_minimal() +
  labs(
    title = "UK Technology Adoption Curves by Income Decile",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(legend.position = "bottom")

# You might also want to see just one technology to compare scenarios more clearly
ggplot(
  adoption_curves %>% filter(technology == "Hybrid/EV"),
  aes(x = year, y = adoption, color = factor(decile))
) +
  geom_line() +
  facet_wrap(~scenario) +
  theme_minimal() +
  labs(
    title = "EV Adoption Curves by Income Decile",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  )

```
```{r additional costs, echo=FALSE}
# First, let's confirm our kwh impacts from technology_consumption
print(technology_consumption)

# Calculate additional demand with new adoption curves
new_additional_demand <- adoption_curves %>%
  # Join with technology consumption assumptions
  left_join(technology_consumption, by = "technology") %>%
  # Join with electricity prices (using 2021 prices)
  left_join(elec_prices_2021, by = "country") %>%
  # Drop year.y and rename year.x to year
  dplyr::select(-year.y) %>%
  rename(year = year.x) %>%
  # Calculate costs
  mutate(
    adoption_rate = adoption / 100,  # Convert percentage to decimal
    additional_kwh = adoption_rate * kwh_per_year,
    additional_cost = additional_kwh * (elec_price/100)  # Convert cents to dollars
  )

# Calculate total impact by scenario
new_total_impact <- new_additional_demand %>%
  group_by(year, country, decile, scenario) %>%
  summarise(
    total_additional_cost = sum(additional_cost),
    .groups = 'drop'
  )

# Visualize the new projections
ggplot(new_total_impact, 
       aes(x = year, y = total_additional_cost, color = factor(decile))) +
  geom_line() +
  facet_grid(scenario ~ country, scales = "free_y") +
  scale_y_continuous(labels = scales::dollar_format()) +
  theme_minimal() +
  labs(
    title = "Projected Additional Annual Electricity Costs with New Adoption Curves",
    subtitle = "By country and adoption scenario",
    y = "Net Change in Electricity Costs (USD)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(legend.position = "bottom")

```


```{r technology specific s-curve, echo=FALSE}
create_adoption_curve <- function(
  technology, 
  decile,
  country,
  start_year = 2021,
  end_year = 2050,
  start_value,
  scenario = "conservative"
) {
  
  # Technology-specific parameters
  tech_params <- list(
    "Hybrid/EV" = list(
      base_max = 80,
      aggressive_k = 0.20,
      conservative_k = 0.10,
      aggressive_midpoint = 2033,
      conservative_midpoint = 2038
    ),
    "Solar Panels" = list(
      base_max = 40,
      aggressive_k = 0.15,
      conservative_k = 0.08,
      aggressive_midpoint = 2035,
      conservative_midpoint = 2040
    ),
    "Internet access" = list(
      base_max = 100,
      aggressive_k = 0.25,  # Fast adoption
      conservative_k = 0.15,
      aggressive_midpoint = 2030,
      conservative_midpoint = 2035
    ),
    "Owns a Smartphone" = list(
      base_max = 100,
      aggressive_k = 0.25,  # Fast adoption
      conservative_k = 0.15,
      aggressive_midpoint = 2030,
      conservative_midpoint = 2035
    ),
    "Digital Skills" = list(
      base_max = 90,
      aggressive_k = 0.18,
      conservative_k = 0.12,
      aggressive_midpoint = 2032,
      conservative_midpoint = 2037
    ),
    "Clean Heating Switch" = list(
      base_max = 70,
      aggressive_k = 0.15,
      conservative_k = 0.08,
      aggressive_midpoint = 2035,
      conservative_midpoint = 2040
    ),
    "Home Renovations" = list(
      base_max = 60,
      aggressive_k = 0.12,
      conservative_k = 0.06,
      aggressive_midpoint = 2037,
      conservative_midpoint = 2042
    ),
    "Sustainable Transport" = list(
      base_max = 50,
      aggressive_k = 0.15,
      conservative_k = 0.08,
      aggressive_midpoint = 2035,
      conservative_midpoint = 2040
    )
  )
  
  # Get parameters for this technology
  params <- tech_params[[technology]]
  
  # Adjust max adoption by decile
  decile_adjustment <- (decile - 5.5) * 5  # Deciles 1-10 get -22.5 to +22.5 adjustment
  max_adoption <- min(100, params$base_max + decile_adjustment)
  
  # Set growth rate and midpoint based on scenario
  if(scenario == "aggressive") {
    k <- params$aggressive_k + (decile/100)
    midpoint <- params$aggressive_midpoint - (decile/10)
  } else {
    k <- params$conservative_k + (decile/200)
    midpoint <- params$conservative_midpoint - (decile/20)
  }
  
  # Generate years
  years <- start_year:end_year
  
  # Ensure start_value doesn't exceed max_adoption
  start_value <- min(start_value, max_adoption)
  
  # Calculate adoption for each year
  adoption <- tibble(
    year = years,
    adoption = max_adoption / (1 + exp(-k * (years - midpoint))),
    decile = decile,
    technology = technology,
    country = country,
    scenario = scenario
  )
  
  return(adoption)
}

# UK visualization
ggplot(adoption_curves %>% filter(country == "UK"), 
       aes(x = year, y = adoption, color = factor(decile))) +
  geom_line() +
  facet_grid(scenario ~ technology, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "UK Technology Adoption Curves by Income Decile",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# US visualization
ggplot(adoption_curves %>% filter(country == "US"), 
       aes(x = year, y = adoption, color = factor(decile))) +
  geom_line() +
  facet_grid(scenario ~ technology, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "US Technology Adoption Curves by Income Decile",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Germany visualization
ggplot(adoption_curves %>% filter(country == "Germany"), 
       aes(x = year, y = adoption, color = factor(decile))) +
  geom_line() +
  facet_grid(scenario ~ technology, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Germany Technology Adoption Curves by Income Decile",
    subtitle = "Comparing Conservative vs Aggressive Scenarios",
    y = "Adoption Rate (%)",
    x = "Year",
    color = "Income Decile"
  ) +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```